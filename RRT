# D = [0,100]x[0,100]
# Initial position - q_init = (50,50)
# Move distance delta = 1

import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from matplotlib.collections import CircleCollection
#import imageio as imag
import random


# Delete this otherwise random will be same number sequence
# Fixing random state for reproducibility
# np.random.seed(19680801) 


"""         RRT Class           """


class RRT:
    # Variables 
    def __init__(self):
        self.vertices_list = [] # (G) Has form [Node name, [node coordinate], [node parent cooordinate]]
        self.edge = [] # Holds the edges/line coordinates of the nodes/vertices
        self.K = 100 # Number of itterations/vertices/nodes
        self.q_init = [50,50] # Starting position
        self.q_near = [] # This is the nearest node to the random point
        self.q_rand = [] # Contains the new random node from "def rand_point(self)"
        self.q_new = [] # Used to store the new node on a unit vecto
        self.delta = 1 # Move distance for each step from parent to new child
        # Explore domain/matrix
        self.D = np.zeros((100,100)) # 2D domain to explore



    """         Functions           """

    # Creates a random point
    def Random_configuration(self):
        rand_point_x = np.random.randint(0,self.D.shape[0])
        rand_point_y = np.random.randint(0,self.D.shape[1])
        return [rand_point_x, rand_point_y]






    # Determins the nearest node and adds it to the vertices list in this config: [node_name,[new node coordinates],[parent node coordinates]]
    def Nearest_node(self, q_rand, vertices_list):
    
        distance_node = [] # Distance between new node and all the existing nodes

        # For loop for calculating the distance between the random point and all the nodes that exists
        for i in range(0,len(vertices_list)): 
            # Pythagorean theorem
            x = np.square(q_rand[0]-vertices_list[i][1][0])
            y = np.square(q_rand[1]-vertices_list[i][1][1])
            pythag = np.sqrt(x+y)
            #print("Euclidean distance from x to y: ", pythag)

            distance_node.append(pythag)
        
        #print('\n Distance node: ', distance_node)

        # Returns the minimum distance and the index of the min distance in the list distance_node
        min_dist = min(distance_node)
        min_index = distance_node.index(min_dist)

        # GET PARENT
        parent = vertices_list[min_index][1]
        #print('min: ', min_dist,'index: ', min_index, 'parent: ', parent)

        # Return parent/q_near
        return parent
        



    def New_configuration(self, q_near, q_rand, delta):
        
        # Calculate the unit vector
        distance = [q_rand[0] - q_near[0], q_rand[1] - q_near[1]]
        norm = np.sqrt([(np.square(q_rand[0] - q_near[0])) + (np.square(q_rand[1] - q_near[1]))])
        unit_vector = distance/norm 
        # print('distance: ',distance ,' norm: ', norm,' unit_vector: ', unit_vector)

        new_node = q_near + unit_vector
        # print('\n new_node: ', new_node)

        return new_node




"""         Random Circle Generator Class     """

class Random_Circle_Generator:
    # Variables 
    def __init__(self):
        self.circle_list = [] # Has form [[center], [radius]] - Nested list
        self.C = 100 # Number of Circles
        self.c_rand = [] # Contains the new random circle parameters [[center],[radius]] from "def rand_circle(self)"
        self.max_radius = 10 # Maximum radius that can be created
    

        """         Functions           """

    # Creates a random point
    def Random_circle_configuration(self, D):
        rand_centre_x = np.random.randint(0,D.shape[0])
        rand_centre_y = np.random.randint(0,D.shape[1])
        rand_radius = np.random.randint(1,self.max_radius+1) # '+1' because high is exlusive and low is inclusive
        return [[rand_centre_x, rand_centre_y], rand_radius]





"""                                    Main Body Code Starts                                      """



RRT1 = RRT() # Create an object of class RRT
RCG1 = Random_Circle_Generator() # Create onject for random circle generator


"""         Random circle generator code           """
n = 0 # Counter for creating X amount of circles (Needs to only be updated when a valid circle is created)

while n < 1:
    n+=1 # Move to update only when valid cicrcle is generated
    #random_circle_config = RCG1.Random_circle_configuration(RRT1.D)
    #RCG1.circle_list.append(random_circle_config)
    RCG1.circle_list.append(RCG1.Random_circle_configuration(RRT1.D))
    print('\n RCG1.circle_list = ',RCG1.circle_list)






# Add starting position/node to vertice list
RRT1.vertices_list.append([len(RRT1.vertices_list), RRT1.q_init, [50,50]]) \





"""         While iteration loop for RRT           """

t = 0 # counting var for While
# MAIN while loop
while t < RRT1.K:
    t += 1 # Increment the counter

    # Generate a random point
    RRT1.q_rand = RRT1.Random_configuration()
    #print(RRT1.q_rand)

    # Get nearest vertex
    RRT1.q_near = RRT1.Nearest_node(RRT1.q_rand, RRT1.vertices_list) # Send the new eandom node and the vertices list
    #print(RRT1.q_near) # Parent

    RRT1.q_new = RRT1.New_configuration(RRT1.q_near, RRT1.q_rand, RRT1.delta)

    #print('RRT1.q_new: ', RRT1.q_new)

    # 1ste arg: Name of new node, 2nd argument: New child/node cooordinate, 3rd argument: Parent coordinates
    RRT1.vertices_list.append([len(RRT1.vertices_list), RRT1.q_new, RRT1.q_near]) 

    





#print('RRT1: ', RRT1.vertices_list, '\n')


"""         Plotting RRT           """


# create random data
data = RRT1.vertices_list


                    ### PLOT LINE COLLECTION ###

line_data = [] # Used to store each line segments two point - child and parent

for i in range(0,len(data)):
    line_data.append([data[i][1],data[i][2]]) #First one is the child and the second one is the parent

lc = LineCollection(line_data) # Make into a collection

# plot the data
fig = plt.figure()
ax = fig.add_subplot()
ax.add_collection(lc)



                    ### PLOT CIRCLE COLLECTION ###

"""Single random circle plot"""
#rawing_colored_circle = plt.Circle(( RCG1.circle_list[0][0][0] , RCG1.circle_list[0][0][1] ), RCG1.circle_list[0][1], color = 'black' )
#ax.add_artist( Drawing_colored_circle )
"""Collection random circle plot"""
#print('RCG1.circle_list[0][1] =', RCG1.circle_list[0][1], '\n')
#print('RCG1.circle_list[0][0] =', RCG1.circle_list[0][0], '\n')

circle_radius_list = []
circle_centre_list = []
#Add for loop to loop through RCG1.circle_list and append all RADIUS
for i in range(0,len(RCG1.circle_list)):
    circle_radius_list.append(RCG1.circle_list[i][1])
    #Add for loop to loop through RCG1.circle_list and append all CENTRE COORS
    circle_centre_list.append(RCG1.circle_list[i][0])

Circle_Params = CircleCollection([circle_radius_list], offsets = circle_centre_list, transOffset=ax.transData, color = 'black') # Make into a collection


#Circle_Params = CircleCollection([RCG1.circle_list[0][1]], offsets = RCG1.circle_list[0][0], transOffset=ax.transData, color = 'black') # Make into a collection
#Circle_Params = CircleCollection([10], offsets = [15,15], transOffset=ax.transData ,color = 'black') # Make into a collection
ax.add_collection(Circle_Params)


# set the limits
ax.set_xlim([0, 100])
ax.set_ylim([0, 100])

ax.set_title('Rapid Exploring Random Tree')

# display the plot
plt.show()

