# D = [0,100]x[0,100]
# Initial position - q_init = (50,50)
# Move distance delta = 1

import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
#import imageio as imag
import random


# Delete this otherwise random will be same number sequence
# Fixing random state for reproducibility
np.random.seed(19680801) 


"""         RRT Class           """


class RRT:
    # Variables 
    def __init__(self):
        self.vertices_list = [] # (G) Has form [Node name, [node coordinate], [node parent cooordinate]]
        self.edge = [] # Holds the edges/line coordinates of the nodes/vertices
        self.k = 4 # Number of itterations/vertices/nodes
        self.q_init = [50,50] # Starting position
        self.q_near = [] # This is the nearest node to the random point
        self.q_rand = [] # Contains the new random node from "def rand_point(self)"
        self.delta = 1 # Move distance for each step from parent to new child
        # Explore domai/matrix
        self.D = np.zeros((100,100)) # 2D domain to explore



    """         Functions           """

    # Creates a random point
    def Random_configuration(self):
        rand_point_x = np.random.randint(0,self.D.shape[0])
        rand_point_y = np.random.randint(0,self.D.shape[1])
        return [rand_point_x, rand_point_y]



    # Determins the nearest node and adds it to the vertices list in this config: [node_name,[new node coordinates],[parent node coordinates]]
    def Nearest_node(self, q_rand, vertices_list):

        # Pythagorean theorem
        x = np.square(q_rand[0]-vertices_list[0][1][0])
        y = np.square(q_rand[1]-vertices_list[0][1][1])
        pythag = np.sqrt(x+y)

        #print("Euclidean distance from x to y: ", pythag)














    #def New_configuration(self, qnear,qrandom,delta):





"""         Main Body Code Starts           """



RRT1 = RRT() # Create an object of class RRT



# Add starting position/node to vertice list
RRT1.vertices_list.append([len(RRT1.vertices_list), RRT1.q_init, [50,50]]) 





# Generate a random point
RRT1.q_rand = RRT1.Random_configuration()

print(RRT1.q_rand)



# Get nearest vertex
RRT1.Nearest_node(RRT1.q_rand, RRT1.vertices_list) # Send the new eandom node and the vertices list


# NB change the 3rd argument to save the parent this will come from def nearest_node function
#vertices_list.append([len(vertices_list), [should be new node coor], [parent coor]]) 






#RRT1.vertices_list.append([len(RRT1.vertices_list), [60,70], [50,50]])
#RRT1.vertices_list.append([len(RRT1.vertices_list), [62,83], [60,70]])
#RRT1.vertices_list.append([len(RRT1.vertices_list), [80,90], [62,83]])



"""         Plotting RRT           """


# create random data
data = RRT1.vertices_list

line_data = [] # Used to store each line segments two point - child and parent

for i in range(0,len(data)):
    line_data.append([data[i][1],data[i][2]]) #First one is the child and the second one is the paretn

lc = LineCollection(line_data) # Make into a collection

# plot the data
fig = plt.figure()
ax = fig.add_subplot()
ax.add_collection(lc)

# set the limits
ax.set_xlim([0, 100])
ax.set_ylim([0, 100])

ax.set_title('Rapid Exploring Random Tree')

# display the plot
plt.show()
